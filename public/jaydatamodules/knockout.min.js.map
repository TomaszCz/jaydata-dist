{"version":3,"sources":["node_modules/browser-pack/_prelude.js","knockout.js","src/JayDataModules/knockout.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","$data","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_dereq_","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_core","_core2","_ko","_ko2","ObservableFactory","originalType","observableClassNem","instanceDefinition","constructor","_this","getEntity","propertyChanged","attach","sender","val","deepEqual","propertyName","newValue","deepConvert","retrieveProperty","memberDefinition","name","backingFieldName","koProperty","type","originalValue","subscribe","oldVal","Array","isArray","slice","deepReconvert","storeProperty","equalityComparers","observable","properties","memberDefinitions","getPublicMappedProperties","l","propName","observableArray","Class","defineEx","KoObservableEntity","params","ConstructorParameter","isWrappedType","Container","registerConverter","keys","converters","to","forEach","typeName","origConverter","undefined","isObservable","apply","arguments","Guard","raise","Exception","map","it","Entity","asKoObservable","peek","oldValue","fireChange","checkObservableValue","expression","context","Expressions","ConstantExpression","some","item","skipExecute","push","observableValue","createConstantExpression","getTypeName","prVisitor","ParameterResolverVisitor","prototype","VisitProperty","eNode","resolvedObservables","qecVisitConstantExpression","QueryExpressionCreator","VisitConstantExpression","VisitCodeExpression","source","toString","jsCodeTree","createCodeParser","scopeContext","createExpression","log","event","data","constantResolver","createConstantValueResolver","parameters","__global","parameterProcessor","createParameterResolverVisitor","Visit","concat","code2entity","createCodeToEntityConverter","entityExpression","queryParameters","lambdaParameters","lambdaTypes","frameType","result","createParametricQueryExpression","qecVisit","expressionRes","FrameOperator","observables","baseExpression","esExecuteQuery","EntityContext","executeQuery","on_ready","transaction","obsObj","preparator","createQueryExpressionCreator","newExpression","createQueryable","EntityWrapper","extend","innerData","wrappedType","isAssignableTo","innerInstance","fullName","_wrappedType","updateEntity","entity","members","memDef","idx","changedProperties","indexOf","splice","getProperties","props","getType","koData","memberInfo","owner","metadata","observableTypeName","namespace","isTypeRegistered","observableType","resolveType","queryableToArray","Queryable","toArray","onResult_items","PromiseHandlerBase","createCallbackSettings","results","tran","requiredError","jaydata/core"],"mappings":"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","file":"knockout.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","﻿// JayData 1.5.13 \r\n// Dual licensed under MIT and GPL v2\r\n// Copyright JayStack Technologies (http://jaydata.org/licensing)\r\n//\r\n// JayData is a standards-based, cross-platform Javascript library and a set of\r\n// practices to access and manipulate data from various online and offline sources.\r\n//\r\n// Credits:\r\n//     Hajnalka Battancs, Dániel József, János Roden, László Horváth, Péter Nochta\r\n//     Péter Zentai, Róbert Bónay, Szabolcs Czinege, Viktor Borza, Viktor Lázár,\r\n//     Zoltán Gyebrovszki, Gábor Dolla\r\n//\r\n// More info: http://jaydata.org\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define(\"jaydata/modules/knockout\",[\"jaydata/core\"],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.$data = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\n\nvar _ko2 = _interopRequireDefault(_ko);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(function ($data) {\n\n    /*converters*/\n    Object.keys($data.Container.converters.to).forEach(function (typeName) {\n        var origConverter = $data.Container.converters.to[typeName] ? $data.Container.converters.to[typeName]['$data.Function'] || $data.Container.converters.to[typeName]['default'] : undefined;\n        $data.Container.registerConverter(typeName, '$data.Function', function (value) {\n            if (_ko2.default.isObservable(value)) {\n                return value;\n            } else if (origConverter) {\n                return origConverter.apply($data.Container.converters[typeName], arguments);\n            } else {\n                _core.Guard.raise(new _core.Exception('Type Error', 'value is not koObservable', value));\n            }\n        });\n    });\n\n    var deepConvert = function deepConvert(value) {\n        if (Array.isArray(value)) {\n            return value.map(function (it) {\n                if (it instanceof $data.Entity) {\n                    return it.asKoObservable();\n                }\n                return it;\n            });\n        } else if (value instanceof $data.Entity) {\n            return value.asKoObservable();\n        }\n        return value;\n    };\n\n    var deepReconvert = function deepReconvert(value) {\n        if (Array.isArray(value)) return value.map(deepReconvert);\n        if (_ko2.default.isObservable(value)) {\n            value = value.peek();\n            return deepReconvert(value);\n        }\n        if (value && typeof value.getEntity == \"function\") {\n            value = value.getEntity();\n        }\n        return value;\n    };\n\n    var deepEqual = function deepEqual(oldValue, newValue) {\n        oldValue = deepReconvert(oldValue);\n        newValue = deepReconvert(newValue);\n        if (Array.isArray(newValue)) {\n            var fireChange = false;\n            for (var i = 0; i < newValue.length; i++) {\n                if (oldValue[i] != newValue[i]) {\n                    fireChange = true;\n                    break;\n                }\n            }\n            if (oldValue.length != newValue.length) fireChange = true;\n            if (fireChange) return false;\n        } else if (oldValue !== newValue) {\n            return false;\n        }\n        return true;\n    };\n\n    function ObservableFactory(originalType, observableClassNem) {\n        var instanceDefinition = {\n            constructor: function constructor() {\n                var _this = this;\n\n                _this.getEntity().propertyChanged.attach(function (sender, val) {\n                    if (!deepEqual(_this[val.propertyName], val.newValue)) _this[val.propertyName](deepConvert(val.newValue));\n                });\n            },\n\n            retrieveProperty: function retrieveProperty(memberDefinition) {\n                var _this = this;\n                var propertyName = memberDefinition.name;\n                var backingFieldName = \"_\" + propertyName;\n\n                if (!_this[backingFieldName]) {\n                    var value = _this.getEntity()[propertyName];\n\n                    value = deepConvert(value);\n\n                    var koProperty = new memberDefinition.type(value);\n\n                    var originalValue = _this[backingFieldName];\n                    koProperty.subscribe(function (oldVal) {\n                        originalValue = Array.isArray(oldVal) ? oldVal.slice() : oldVal;\n                    }, null, \"beforeChange\");\n                    koProperty.subscribe(function (val) {\n                        if (!deepEqual(originalValue, val)) _this[backingFieldName](deepConvert(val));\n                        _this.getEntity()[propertyName] = deepReconvert(val);\n                    });\n\n                    _this[backingFieldName] = koProperty;\n                } else {\n                    if (!deepEqual(_this[backingFieldName], _this.getEntity()[propertyName])) _this[backingFieldName](deepConvert(_this.getEntity()[propertyName]));\n                }\n\n                return _this[backingFieldName];\n            },\n            storeProperty: function storeProperty(memberDefinition, value) {},\n            equalityComparers: { type: _ko2.default.observable }\n        };\n\n        var properties = originalType.memberDefinitions.getPublicMappedProperties();\n        for (var i = 0, l = properties.length; i < l; i++) {\n            var propName = properties[i].name;\n            instanceDefinition[propName] = {\n                type: properties[i].type == Array ? _ko2.default.observableArray : _ko2.default.observable\n            };\n            instanceDefinition[\"ValidationErrors\"] = {\n                type: _ko2.default.observableArray\n            };\n        }\n\n        $data.Class.defineEx(observableClassNem, [{ type: $data.KoObservableEntity, params: [new $data.Class.ConstructorParameter(0), function () {\n                return originalType;\n            }] }], null, instanceDefinition, {\n            isWrappedType: function isWrappedType(type) {\n                return type === originalType;\n            }\n        });\n\n        $data.Container.registerConverter(observableClassNem, originalType, function (value) {\n            return value;\n        }, function (value) {\n            return typeof value.getEntity == \"function\" ? value.getEntity() : value;\n        });\n    };\n\n    if (typeof _ko2.default !== 'undefined') {\n        /* Observable Query*/\n        var checkObservableValue = function checkObservableValue(expression, context) {\n            if (expression instanceof $data.Expressions.ConstantExpression && _ko2.default.isObservable(expression.value)) {\n                context.some(function (item) {\n                    if (item.observable === expression.value) {\n                        item.skipExecute = true;\n                    }\n                });\n                context.push({\n                    observable: expression.value,\n                    skipExecute: false\n                });\n                var observableValue = expression.value();\n                return _core.Container.createConstantExpression(observableValue, _core.Container.getTypeName(observableValue), expression.name + '$Observable');\n            }\n            return expression;\n        };\n\n        var prVisitor = $data.Expressions.ParameterResolverVisitor.prototype.VisitProperty;\n        $data.Expressions.ParameterResolverVisitor.prototype.VisitProperty = function (eNode, context) {\n            var expression = prVisitor.call(this, eNode, context);\n            this.resolvedObservables = this.resolvedObservables || [];\n            return checkObservableValue(expression, this.resolvedObservables);\n        };\n\n        var qecVisitConstantExpression = $data.Expressions.QueryExpressionCreator.prototype.VisitConstantExpression;\n        $data.Expressions.QueryExpressionCreator.prototype.VisitConstantExpression = function (expression, context) {\n            if (qecVisitConstantExpression) expression = qecVisitConstantExpression.call(this, expression, context);\n\n            return checkObservableValue(expression, this.resolvedObservables);\n        };\n\n        //$data.Expressions.QueryExpressionCreator.prototype.resolvedObservables = [];\n        var qecVisitCodeExpression = $data.Expressions.QueryExpressionCreator.prototype.VisitCodeExpression;\n        $data.Expressions.QueryExpressionCreator.prototype.VisitCodeExpression = function (expression, context) {\n            ///<summary>Converts the CodeExpression into an EntityExpression</summary>\n            ///<param name=\"expression\" type=\"$data.Expressions.CodeExpression\" />\n            var source = expression.source.toString();\n            var jsCodeTree = _core.Container.createCodeParser(this.scopeContext).createExpression(source);\n            this.scopeContext.log({ event: \"JSCodeExpression\", data: jsCodeTree });\n\n            //TODO rename classes to reflex variable names\n            //TODO engage localValueResolver here\n            //var globalVariableResolver = Container.createGlobalContextProcessor($data.__global);\n            var constantResolver = _core.Container.createConstantValueResolver(expression.parameters, $data.__global, this.scopeContext);\n            var parameterProcessor = _core.Container.createParameterResolverVisitor();\n\n            jsCodeTree = parameterProcessor.Visit(jsCodeTree, constantResolver);\n\n            //added\n            this.resolvedObservables = (this.resolvedObservables || []).concat(parameterProcessor.resolvedObservables);\n\n            this.scopeContext.log({ event: \"JSCodeExpressionResolved\", data: jsCodeTree });\n            var code2entity = _core.Container.createCodeToEntityConverter(this.scopeContext);\n\n            ///user provided query parameter object (specified as thisArg earlier) is passed in\n            var entityExpression = code2entity.Visit(jsCodeTree, { queryParameters: expression.parameters, lambdaParameters: this.lambdaTypes, frameType: context.frameType });\n\n            ///parameters are referenced, ordered and named, also collected in a flat list of name value pairs\n            var result = _core.Container.createParametricQueryExpression(entityExpression, code2entity.parameters);\n            this.scopeContext.log({ event: \"EntityExpression\", data: entityExpression });\n\n            return result;\n        };\n\n        var qecVisit = $data.Expressions.QueryExpressionCreator.prototype.Visit;\n        $data.Expressions.QueryExpressionCreator.prototype.Visit = function (expression, context) {\n\n            var expressionRes;\n            if (expression instanceof $data.Expressions.FrameOperator) {\n                this.resolvedObservables = [];\n                var expressionRes = qecVisit.call(this, expression, context);\n\n                expressionRes.observables = this.resolvedObservables;\n                expressionRes.baseExpression = expression;\n            } else {\n                expressionRes = qecVisit.call(this, expression, context);\n            }\n            return expressionRes;\n        };\n\n        var esExecuteQuery = $data.EntityContext.prototype.executeQuery;\n        $data.EntityContext.prototype.executeQuery = function (expression, on_ready, transaction) {\n            var self = this;\n            var observables = expression.expression.observables;\n            if (observables && observables.length > 0) {\n                observables.forEach(function (obsObj) {\n                    if (!obsObj) return;\n\n                    obsObj.observable.subscribe(function () {\n                        if (!obsObj.skipExecute) {\n                            var preparator = _core.Container.createQueryExpressionCreator(self);\n                            var newExpression = preparator.Visit(expression.expression.baseExpression);\n\n                            esExecuteQuery.call(self, _core.Container.createQueryable(expression, newExpression), on_ready, transaction);\n                        }\n                    });\n                });\n            }\n\n            esExecuteQuery.call(self, expression, on_ready, transaction);\n        };\n\n        /* Observable Query End*/\n\n        /* Observable entities */\n        $data.EntityWrapper.extend('$data.KoObservableEntity', {\n            constructor: function constructor(innerData, wrappedType) {\n                if (!(wrappedType && wrappedType.isAssignableTo && wrappedType.isAssignableTo($data.Entity))) {\n                    _core.Guard.raise(new _core.Exception(\"Type: '\" + wrappedType + \"' is not assignable to $data.Entity\"));\n                }\n\n                var innerInstance;\n                if (innerData instanceof wrappedType) {\n                    innerInstance = innerData;\n                } else if (innerData instanceof $data.Entity) {\n                    _core.Guard.raise(new _core.Exception(\"innerData is instance of '$data.Entity' instead of '\" + wrappedType.fullName + \"'\"));\n                } else {\n                    innerInstance = new wrappedType(innerData);\n                }\n\n                this._wrappedType = wrappedType;\n                this.innerInstance = innerInstance;\n            },\n            getEntity: function getEntity() {\n                return this.innerInstance;\n            },\n            updateEntity: function updateEntity(entity) {\n                var data;\n                if (entity instanceof this._wrappedType) data = entity;else if (entity && !(entity instanceof $data.Entity) && entity instanceof $data.Object) data = entity;else _core.Guard.raise('entity is an invalid object');\n\n                var members = this._wrappedType.memberDefinitions.getPublicMappedProperties();\n                for (var i = 0; i < members.length; i++) {\n                    var memDef = members[i];\n                    if (data[memDef.name] !== undefined) {\n                        this[memDef.name](data[memDef.name]);\n                        var idx = this.innerInstance.changedProperties.indexOf(memDef);\n                        if (idx >= 0) this.innerInstance.changedProperties.splice(idx, 1);\n                    }\n                }\n            },\n\n            getProperties: function getProperties() {\n                //todo cache!\n                var self = this;\n                var props = this.innerInstance.getType().memberDefinitions.getPublicMappedProperties();\n                //todo remove map\n                var koData = props.map(function (memberInfo) {\n                    return {\n                        type: memberInfo.type,\n                        name: memberInfo.name,\n                        owner: self,\n                        metadata: memberInfo,\n                        value: self[memberInfo.name]\n                    };\n                });\n                return koData;\n            }\n        });\n\n        $data.Entity.prototype.asKoObservable = function () {\n            var type = this.getType();\n            var observableTypeName = (type.namespace ? type.namespace + '.' : '') + 'Observable' + type.name;\n            if (!_core.Container.isTypeRegistered(observableTypeName)) {\n                ObservableFactory(type, observableTypeName);\n            }\n            var observableType = _core.Container.resolveType(observableTypeName);\n\n            if (!observableType.isWrappedType(type)) {\n                ObservableFactory(type, observableTypeName);\n                observableType = _core.Container.resolveType(observableTypeName);\n            }\n\n            return new observableType(this);\n        };\n\n        var queryableToArray = $data.Queryable.prototype.toArray;\n        $data.Queryable.prototype.toArray = function (onResult_items, transaction) {\n            if (_ko2.default.isObservable(onResult_items)) {\n                if (typeof onResult_items.push !== 'undefined') {\n                    var callBack = $data.PromiseHandlerBase.createCallbackSettings();\n\n                    return this.toArray(function (results, tran) {\n                        onResult_items(results.map(function (it) {\n                            return it instanceof $data.Entity ? it.asKoObservable() : it;\n                        }));\n                    }, transaction);\n                } else {\n                    return queryableToArray.call(this, function (result, tran) {\n                        onResult_items(result);\n                    }, transaction);\n                }\n            } else {\n                return queryableToArray.call(this, onResult_items, transaction);\n            }\n        };\n        /* Observable entities End*/\n    } else {\n        var requiredError = function requiredError() {\n            _core.Guard.raise(new _core.Exception('Knockout js is required', 'Not Found!'));\n        };\n\n        $data.Entity.prototype.asKoObservable = requiredError;\n    }\n})(_core2.default);\n\nexports.default = _core2.default;\nmodule.exports = exports['default'];\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"jaydata/core\":\"jaydata/core\"}]},{},[1])(1)\n});\n\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\nimport ko from 'ko'\r\n\r\n\r\n(function ($data) {\r\n\r\n    /*converters*/\r\n    Object.keys($data.Container.converters.to).forEach(function (typeName) {\r\n        var origConverter = $data.Container.converters.to[typeName] ? $data.Container.converters.to[typeName]['$data.Function'] || $data.Container.converters.to[typeName]['default'] : undefined;\r\n        $data.Container.registerConverter(typeName, '$data.Function', function (value) {\r\n            if (ko.isObservable(value)) {\r\n                return value;\r\n            } else if (origConverter) {\r\n                return origConverter.apply($data.Container.converters[typeName], arguments);\r\n            } else {\r\n                Guard.raise(new Exception('Type Error', 'value is not koObservable', value));\r\n            }\r\n        });\r\n    });\r\n\r\n    var deepConvert = function(value){\r\n        if (Array.isArray(value)){\r\n            return value.map(function(it){\r\n                if (it instanceof $data.Entity){\r\n                    return it.asKoObservable();\r\n                }\r\n                return it;\r\n            });\r\n        }else if (value instanceof $data.Entity){\r\n            return value.asKoObservable();\r\n        }\r\n        return value;\r\n    };\r\n\r\n    var deepReconvert = function deepReconvert(value) {\r\n        if (Array.isArray(value)) return value.map(deepReconvert);\r\n        if (ko.isObservable(value)){\r\n            value = value.peek();\r\n            return deepReconvert(value);\r\n        }\r\n        if (value && typeof value.getEntity == \"function\"){\r\n            value = value.getEntity();\r\n        }\r\n        return value;\r\n    };\r\n\r\n    var deepEqual = function deepEqual(oldValue, newValue){\r\n        oldValue = deepReconvert(oldValue);\r\n        newValue = deepReconvert(newValue);\r\n        if (Array.isArray(newValue)){\r\n            var fireChange = false;\r\n            for (var i = 0; i < newValue.length; i++){\r\n                if (oldValue[i] != newValue[i]){\r\n                    fireChange = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (oldValue.length != newValue.length) fireChange = true;\r\n            if (fireChange) return false;\r\n        }else if (oldValue !== newValue) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    function ObservableFactory(originalType, observableClassNem) {\r\n        var instanceDefinition = {\r\n            constructor: function () {\r\n                var _this = this;\r\n\r\n                _this.getEntity().propertyChanged.attach(function (sender, val) {\r\n                    if (!deepEqual(_this[val.propertyName], val.newValue)) _this[val.propertyName](deepConvert(val.newValue));\r\n                });\r\n            },\r\n\r\n            retrieveProperty: function (memberDefinition) {\r\n                var _this = this;\r\n                var propertyName = memberDefinition.name\r\n                var backingFieldName = \"_\" + propertyName;\r\n\r\n                if (!_this[backingFieldName]) {\r\n                    var value = _this.getEntity()[propertyName];\r\n\r\n                    value = deepConvert(value);\r\n\r\n                    var koProperty = new (memberDefinition.type)(value);\r\n\r\n                    var originalValue = _this[backingFieldName];\r\n                    koProperty.subscribe(function (oldVal) {\r\n                        originalValue = Array.isArray(oldVal) ? oldVal.slice() : oldVal;\r\n                    }, null, \"beforeChange\");\r\n                    koProperty.subscribe(function (val) {\r\n                        if (!deepEqual(originalValue, val)) _this[backingFieldName](deepConvert(val));\r\n                        _this.getEntity()[propertyName] = deepReconvert(val);\r\n                    });\r\n\r\n                    _this[backingFieldName] = koProperty;\r\n                }else{\r\n                    if (!deepEqual(_this[backingFieldName], _this.getEntity()[propertyName])) _this[backingFieldName](deepConvert(_this.getEntity()[propertyName]));\r\n                }\r\n\r\n                return _this[backingFieldName];\r\n            },\r\n            storeProperty: function (memberDefinition, value) {\r\n            },\r\n            equalityComparers: { type: ko.observable }\r\n        };\r\n\r\n        var properties = originalType.memberDefinitions.getPublicMappedProperties();\r\n        for (var i = 0, l = properties.length; i < l; i++) {\r\n            var propName = properties[i].name;\r\n            instanceDefinition[propName] = {\r\n                type: properties[i].type == Array ? ko.observableArray : ko.observable\r\n            };\r\n            instanceDefinition[\"ValidationErrors\"] = {\r\n                type: ko.observableArray\r\n            };\r\n        }\r\n\r\n        $data.Class.defineEx(\r\n            observableClassNem,\r\n            [{ type: $data.KoObservableEntity, params: [new $data.Class.ConstructorParameter(0), function () { return originalType }] }],\r\n            null,\r\n            instanceDefinition,\r\n            {\r\n                isWrappedType: function (type) { return type === originalType; }\r\n            });\r\n\r\n        $data.Container.registerConverter(observableClassNem, originalType, function (value) {\r\n            return value;\r\n        }, function (value) {\r\n            return typeof value.getEntity == \"function\" ? value.getEntity() : value;\r\n        });\r\n    };\r\n\r\n    if (typeof ko !== 'undefined') {\r\n        /* Observable Query*/\r\n        function checkObservableValue(expression, context) {\r\n            if (expression instanceof $data.Expressions.ConstantExpression && ko.isObservable(expression.value)) {\r\n                context.some(function (item) {\r\n                    if (item.observable === expression.value) {\r\n                        item.skipExecute = true;\r\n                    }\r\n                });\r\n                context.push({\r\n                    observable: expression.value,\r\n                    skipExecute: false\r\n                });\r\n                var observableValue = expression.value();\r\n                return Container.createConstantExpression(observableValue, Container.getTypeName(observableValue), expression.name + '$Observable');\r\n            }\r\n            return expression;\r\n        }\r\n\r\n        var prVisitor = $data.Expressions.ParameterResolverVisitor.prototype.VisitProperty;\r\n        $data.Expressions.ParameterResolverVisitor.prototype.VisitProperty = function (eNode, context) {\r\n            var expression = prVisitor.call(this, eNode, context);\r\n            this.resolvedObservables = this.resolvedObservables || [];\r\n            return checkObservableValue(expression, this.resolvedObservables);\r\n        }\r\n\r\n        var qecVisitConstantExpression = $data.Expressions.QueryExpressionCreator.prototype.VisitConstantExpression;\r\n        $data.Expressions.QueryExpressionCreator.prototype.VisitConstantExpression = function (expression, context) {\r\n            if (qecVisitConstantExpression)\r\n                expression = qecVisitConstantExpression.call(this, expression, context);\r\n\r\n            return checkObservableValue(expression, this.resolvedObservables);\r\n        }\r\n\r\n        //$data.Expressions.QueryExpressionCreator.prototype.resolvedObservables = [];\r\n        var qecVisitCodeExpression = $data.Expressions.QueryExpressionCreator.prototype.VisitCodeExpression;\r\n        $data.Expressions.QueryExpressionCreator.prototype.VisitCodeExpression = function (expression, context) {\r\n            ///<summary>Converts the CodeExpression into an EntityExpression</summary>\r\n            ///<param name=\"expression\" type=\"$data.Expressions.CodeExpression\" />\r\n            var source = expression.source.toString();\r\n            var jsCodeTree = Container.createCodeParser(this.scopeContext).createExpression(source);\r\n            this.scopeContext.log({ event: \"JSCodeExpression\", data: jsCodeTree });\r\n\r\n            //TODO rename classes to reflex variable names\r\n            //TODO engage localValueResolver here\r\n            //var globalVariableResolver = Container.createGlobalContextProcessor($data.__global);\r\n            var constantResolver = Container.createConstantValueResolver(expression.parameters, $data.__global, this.scopeContext);\r\n            var parameterProcessor = Container.createParameterResolverVisitor();\r\n\r\n            jsCodeTree = parameterProcessor.Visit(jsCodeTree, constantResolver);\r\n\r\n            //added\r\n            this.resolvedObservables = (this.resolvedObservables || []).concat(parameterProcessor.resolvedObservables);\r\n\r\n            this.scopeContext.log({ event: \"JSCodeExpressionResolved\", data: jsCodeTree });\r\n            var code2entity = Container.createCodeToEntityConverter(this.scopeContext);\r\n\r\n            ///user provided query parameter object (specified as thisArg earlier) is passed in\r\n            var entityExpression = code2entity.Visit(jsCodeTree, { queryParameters: expression.parameters, lambdaParameters: this.lambdaTypes, frameType: context.frameType });\r\n\r\n            ///parameters are referenced, ordered and named, also collected in a flat list of name value pairs\r\n            var result = Container.createParametricQueryExpression(entityExpression, code2entity.parameters);\r\n            this.scopeContext.log({ event: \"EntityExpression\", data: entityExpression });\r\n\r\n            return result;\r\n        }\r\n\r\n        var qecVisit = $data.Expressions.QueryExpressionCreator.prototype.Visit;\r\n        $data.Expressions.QueryExpressionCreator.prototype.Visit = function (expression, context) {\r\n\r\n            var expressionRes;\r\n            if (expression instanceof $data.Expressions.FrameOperator) {\r\n                this.resolvedObservables = [];\r\n                var expressionRes = qecVisit.call(this, expression, context);\r\n\r\n                expressionRes.observables = this.resolvedObservables;\r\n                expressionRes.baseExpression = expression;\r\n\r\n            } else {\r\n                expressionRes = qecVisit.call(this, expression, context);\r\n            }\r\n            return expressionRes;\r\n        };\r\n\r\n        var esExecuteQuery = $data.EntityContext.prototype.executeQuery;\r\n        $data.EntityContext.prototype.executeQuery = function (expression, on_ready, transaction) {\r\n            var self = this;\r\n            var observables = expression.expression.observables;\r\n            if (observables && observables.length > 0) {\r\n                observables.forEach(function (obsObj) {\r\n                    if (!obsObj)\r\n                        return;\r\n\r\n                    obsObj.observable.subscribe(function () {\r\n                        if (!obsObj.skipExecute) {\r\n                            var preparator = Container.createQueryExpressionCreator(self);\r\n                            var newExpression = preparator.Visit(expression.expression.baseExpression);\r\n\r\n                            esExecuteQuery.call(self, Container.createQueryable(expression, newExpression), on_ready, transaction);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n            esExecuteQuery.call(self, expression, on_ready, transaction);\r\n        };\r\n\r\n        /* Observable Query End*/\r\n\r\n        /* Observable entities */\r\n        $data.EntityWrapper.extend('$data.KoObservableEntity', {\r\n            constructor: function (innerData, wrappedType) {\r\n                if (!(wrappedType && wrappedType.isAssignableTo && wrappedType.isAssignableTo($data.Entity))) {\r\n                    Guard.raise(new Exception(\"Type: '\" + wrappedType + \"' is not assignable to $data.Entity\"));\r\n                }\r\n\r\n                var innerInstance;\r\n                if (innerData instanceof wrappedType) {\r\n                    innerInstance = innerData;\r\n                } else if (innerData instanceof $data.Entity) {\r\n                    Guard.raise(new Exception(\"innerData is instance of '$data.Entity' instead of '\" + wrappedType.fullName + \"'\"));\r\n                } else {\r\n                    innerInstance = new wrappedType(innerData);\r\n                }\r\n\r\n                this._wrappedType = wrappedType;\r\n                this.innerInstance = innerInstance;\r\n            },\r\n            getEntity: function () {\r\n                return this.innerInstance;\r\n            },\r\n            updateEntity: function (entity) {\r\n                var data;\r\n                if (entity instanceof this._wrappedType)\r\n                    data = entity;\r\n                else if (entity && !(entity instanceof $data.Entity) && entity instanceof $data.Object)\r\n                    data = entity;\r\n                else\r\n                    Guard.raise('entity is an invalid object');\r\n\r\n                var members = this._wrappedType.memberDefinitions.getPublicMappedProperties();\r\n                for (var i = 0; i < members.length; i++) {\r\n                    var memDef = members[i];\r\n                    if (data[memDef.name] !== undefined) {\r\n                        this[memDef.name](data[memDef.name]);\r\n                        var idx = this.innerInstance.changedProperties.indexOf(memDef);\r\n                        if (idx >= 0)\r\n                            this.innerInstance.changedProperties.splice(idx, 1);\r\n                    }\r\n                }\r\n\r\n            },\r\n\r\n            getProperties: function() {\r\n                //todo cache!\r\n                var self = this;\r\n                var props = this.innerInstance.getType().memberDefinitions.getPublicMappedProperties();\r\n                //todo remove map\r\n                var koData = props.map( function(memberInfo) {\r\n                    return {\r\n                        type: memberInfo.type,\r\n                        name: memberInfo.name,\r\n                        owner: self,\r\n                        metadata: memberInfo,\r\n                        value: self[memberInfo.name]\r\n                    }\r\n                });\r\n                return koData;\r\n            }\r\n        });\r\n\r\n        $data.Entity.prototype.asKoObservable = function () {\r\n            var type = this.getType();\r\n            var observableTypeName = (type.namespace ? (type.namespace + '.') : '') + 'Observable' + type.name;\r\n            if (!Container.isTypeRegistered(observableTypeName)) {\r\n                ObservableFactory(type, observableTypeName);\r\n            }\r\n            var observableType = Container.resolveType(observableTypeName);\r\n\r\n            if (!observableType.isWrappedType(type)) {\r\n                ObservableFactory(type, observableTypeName);\r\n                observableType = Container.resolveType(observableTypeName);\r\n            }\r\n\r\n            return new observableType(this);\r\n        };\r\n\r\n        var queryableToArray = $data.Queryable.prototype.toArray;\r\n        $data.Queryable.prototype.toArray = function (onResult_items, transaction) {\r\n            if (ko.isObservable(onResult_items)) {\r\n                if (typeof onResult_items.push !== 'undefined') {\r\n                    var callBack = $data.PromiseHandlerBase.createCallbackSettings();\r\n\r\n                    return this.toArray(function (results, tran) {\r\n                        onResult_items(results.map(function(it){ return it instanceof $data.Entity ? it.asKoObservable() : it; }));\r\n                    }, transaction);\r\n                } else {\r\n                    return queryableToArray.call(this, function (result, tran) { onResult_items(result); }, transaction);\r\n                }\r\n            } else {\r\n                return queryableToArray.call(this, onResult_items, transaction);\r\n            }\r\n        }\r\n        /* Observable entities End*/\r\n\r\n\r\n    } else {\r\n        function requiredError() {\r\n            Guard.raise(new Exception('Knockout js is required', 'Not Found!'));\r\n        }\r\n\r\n        $data.Entity.prototype.asKoObservable = requiredError\r\n    }\r\n\r\n})($data);\r\n\r\nexport default $data\r\n"]}